# JPA-Programming

JPA 사용하는 이유
영속성 컨텍스트 특징
준영속 상태 특징
매핑 어노테이션
양방향 매핑 규칭
즉시로딩 지연로딩



영속성 컨텍스트
- 엔티티를 영구 저장하는 환경의 의미
- EntityManager.persist(entity); --> 영속성 컨텍스트를 통해 엔티티를 영속성 한다 db에 저장하는 것이 아님
- 논리적인 개념, 눈에 보이지 않기 때문
- 엔티티 매니저를 통해 영속성 컨텍스트에 접근 1:1 관계



엔티티의 생명주기
- 비영속(new / transient): 영속성 컨텍스트와 관계 없는 새로운 상태
- 영속(managed): 컨텍스트에 관리되는 상태
- 준영속(detached): 컨텍스트에 저장되었다가 분리된 상태 껍데기는 남아있음
- 삭제(removed): 삭제된 상태


1. 비영속
- jpa와 관계없는 상태
- 객체만 생성한 상태

2. 영속
- 멤버 객체를 생성 후 EntityManager안에 넣어주면 영속 상태가 됨
- persist하는 순간 영속성을 띈다 --> db에 저장되는 형태는 아님
- 트랜잭션 commit 하는 시점에 영속성 컨텍스트가 디비에 날라감

3. 준영속, 삭제
- detached == 영속성 컨텍스트에서 지운다.
- remove == db 삭제를 요청한다.
----------------------------------------------------------------------------------

영속성 컨텍스트의 장점
- 1차 캐시: 영속성 컨텍스트의 의미? find를 하면 db를 바로 가는것이 아닌 1차캐시에서 찾는다 
	       db에는 있는데 1차 캐시에 없다면? --> jpa가 찾고자 하는것을 db에서 조회 찾는다면
                                                                  1차 캐시에 넣어주고 찾을 수 있게 해줌
							      여러명의 고객에서는 이점이 없음

  jpa는 영속성 컨텍스트에 무조건 올려둠, 한번 조회 했던 거 또 조회 하면 db의 쿼리 안날라감(동일 트랜잭션 에서만)
  여러 클라이언트(다 다른 캐시)


- 영속 엔티티의 동일성 보장
: == 비교 시 true 반환 (자바 컬렉션에서 같은 레퍼런스를 꺼내어 비교했을 때와 같음)
 같은 트랜잭션 안에서만!


- 엔티티 등록 시 트랜잭션을 지원하는 쓰기 지연
:  persist시 sql을 데이터 베이스에 보내지 않고 jpa가 쌓고 있으면 commit시 db에 insert를 보낸다

  ex) memberA를 persist시 1차 캐시에 들어가는 동시에 jpa가 엔티티를 분석 후 insert 쿼리를 생성 해서
      쓰기 지연 저장소에 쌓아둔다. memeberB도 넣으면 같은 구조로 동작하여 계속 쌓는다
      tracsaction.commit()시 flush가 되면서 쿼리가 날라가는 방식으로 동작
     ==> 버퍼링 기능 사용하기 위해 == 모았다가 한번에 날림, 계속 쿼리를 날리면 최적화가 불리함
	    

-엔티티 수정 변경 감지
:  값을 변경하고 다시 컬렉션에 집어 넣진 않음!!!!! 그래서 persist를 안해줘도된다.!!!!!!!!!!!!!!!
   jpa는 더티채킹=변경감지 기능으로 엔티티를 수정할 수 있음 ==> update 쿼리를 안날려도됨
  영속성 컨텍스트 flush()기능을 통해 엔티티와 스냅샷을 비교(1차 캐시에는 id, pk, 스냅샷)
  스냅샷이란, 내가 값을 읽어온 시점의 상태를 일단 저장해둠 그리고 값이 변경되면 jpa가 일일이 이 셋을 비교
  엔티티가 수정되면 update를 저장소에 올리고 db와 연결



- 엔티티 삭제
: update와 같은 메카니즘

---------------------결론 수정이나 삭제나 persist를 안날려도 됨 ---------------------


플러시
- 영속성 컨텍스트의 변경 내용과 db를 맞추는 작업 
- 플러시 발생 시: 더티 채킹, 쓰기 지연 sql 저장소(등록, 수정, 삭제 쿼리 등)에 등록
- 영속성 컨텍스트를 플러시하는 방법: em.flush()-직접호출
					       트랜잭션 커밋- 플러시 자동 호출
					        JPQL 쿼리 실행- 플러시 자동 호출

- 1차캐시는 유지됨
- 영속성 컨텍스트를 비우는 것이 아님
- 커밋 직전에만 동기화 하면 됨
- 트랜잭션 단위 별로 돌아감


준영속 상태
- em.find로 db에서 가져왔을 때 1차캐시에 올라온 상태가 영속 상태라면
- 영속 상태에서 다 빼버린 상태. 아무것도 없는 상태?
- em.detach == jpa가 관리 하지 않는다는 의미
- clear == 1차캐시 초기화

-------------------------------------------------------------------------------------
엔티티 매핑
- 객체와 테이블 매핑: @Entity, @Table
- 필드와 컬럼 매핑: @Column
- 기본 키 매핑: @Id
- 연관관계 매핑: @ManyToOne, @JoinColumn   (회원과 이 회원의 팀 관계 시)



1.객체와 테이블 매핑
- @Entity가 붙은 클래스는 JPA가 관리, 엔티티라고 한다
- JPA를 사용하려면 @Entity 필수로 붙여야함
- 기본 생성자 필수(final, interface, inner 클래스 사용x)
- @Table: 테이블이 다른 이름이라면 name 속성으로 직접 설정 가능
  @Table(name="다른 테이블 이름") --> INSERT 시 이 테이블로 FROM절이 설정됨


데이터베이스 스키마 자동 생성
- 객체에 매핑을 다 해놓으면 테이블을 알아서 만들어줌
- db에 맞는 DDL을 적절하게 생성해줌 --> 개발시에만 사용
- properties에서 value값을 create으로 바꾸면 객체 생성 시 자동으로 테이블에 조건 추가
- create_drop = 테이블 삭제
- update = alter
- 지우는것은 안됨
- 데이터베이스에 따라 다르게 설정해줌
- 운영장비에는 절대 create, create-drop, update를 사용하면 안됨
- 개발 초기에는 create 또는 update만 쓰자
- 테스트 서버에는 update, validate
- @Table은 런타임에 영향을 주지만 @Column은 영향을 주지 않는다는 장점



매핑 어노테이션
- @Transient == 메모리에서만 쓰겠다 db에 영향 x

@Column
- 



@Enum 주의사항
- 


직접 id 세팅
@ID만 사용
 
아이덴티티 전략 - 특징
: db에 insert 해봐야 ID값을 알 수 있음.

시퀀스 전략 - 특징
: 



권장하는 식별자 전략
- 기본 키 제약 조건: null이 아님, 유일해야하고, 변하면 안됨
- 대리키(대체키)를 이용하자
- 권장: Long형 + 대체키 + 키 생성전략 사용




연관관계 매핑 기초
- 




양방향 매핑
- 단방향 매핑만으로도 연관관계 매핑은 완료
- 양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색)


mappedBy
- FK 하나로 양쪽의 연관 관계를 알 수 있음
- 객체의 향방향 관계는 사실 양방향이 아닌 서로 다른 단방향 관계 2개이다
- 그렇기에 단방향 연관관계를 2개 만들어야함
- 둘 중 하나로 외래 키를 관리해아 한다. --> 연관관계 매핑
- Owner == 객체간의 관계중 하나를 주인으로 지정해주는 방식 
                외래 키가 있는 곳을 주인으로 지정
- 주인의 반대편 매핑을 가짜 매핑이라고도 한다. 
- 역방향(주인이 아닌 방향)만 연관관계 설정하자
- 항상 양쪽에 값을 설정하자, 무한루프 조심(toString, lombok, JSON)
- 일대다 에서는 없음




다중성
- 단방향, 양방향
  : 테이블 -> 외래 키 하나로 양쪽 조인 가능
    객체 -> 참조용 필드가 있는 쪽으로만 참조 가능 

-일대다 단방향
: 일(1)이 주인
  다(N) 쪽에 외래 키 존재
  객체와 테이블 차이 때문에 반대편 테이블의 외래키를 관리하는 특이함
  @JoinColumn 사용 요망 그렇지 않으면 조인 테이블 방식을 사용함
  일대다 보다는 다대일 양방향 매핑을 사용하자
  
-일대일 관계
: 외래 키에 데이터베이스 유니크 제약조건 추가 필요
  

프록시
- em.find(): db를 통해 실제 엔티티 객제 조회
- em.getReference(): db 조회를 미루는 가짜(프록시) 엔티티 객체 조회
- 실제 클래스를 상속 == 그렇기에 겉 모양이 같다
- 사용자 입장에선 구분하지 않고 사용하면 됨(이론상)
- 프록시에는 실제 객체의 참조(target)를 보관
- 처음 사용할 때 한 번만 초기화 --> 2 3번 해도 초기화는 안됨
- 실제 엔티티로 바뀌는것이 아님
- 원본 엔티티를 상속 받기 때문에, 타입 체크 해야됨 ==이 아닌 instance of 사용 ex) m1 instance of Member
- 영속성 컨텍스트에 찾는 엔티티가 있으면 em.getReference()를 호출해도 실제 엔티티 반환



지연로딩
- fetch 타입을 LAZY로 하면 됨 
- 프록시로 조회 시 
- 실무에서 사용하자!!!!!!!!!!!!!
- 

즉시로딩
- member 조회시 team도 같이 조회
- 조인을 사용해서 sql 한번에 함꼐 조회
- 실무에서는 사용 xxx N+1 문제를 일으킴


영속성 전이: CASCADE
- 특정 엔티티를 영속으로 만들 때 연관된 엔티티도 함께 영속으로 만들어야 할 때
  EX) 부모 엔티티 저장 시 자식 엔티티도 함께 저장


고아객체 주의
- 참조하는 곳이 하나일 때 사용
- 특정 엔티티가 개인 소유할 때 사용
- 




------------------------------------------------------------------
JPQL
- 다양한 검색 조건으로 컬럼 조회 그렇기에 복잡한 쿼리도 짤 수 있음
- 객체로 표현해서 처리한다



----영속성, 연관관계 매핑, 프록시(지연,즉시), 페치?








